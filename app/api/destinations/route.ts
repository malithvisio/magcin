import { NextRequest, NextResponse } from 'next/server';
import connectDB from '@/lib/mongodb';
import Destination from '@/models/Destination';
import {
  getUserContext,
  canCreateContent,
  incrementUsage,
  createTenantFilter,
} from '@/util/tenantContext';

export async function POST(request: NextRequest) {
  try {
    const destinationData = await request.json();

    // Get user context for multi-tenant authentication
    const userContext = await getUserContext(request);

    // Check if user can create more destinations (using root user for quota)
    const quotaCheck = await canCreateContent(
      userContext.rootUserId,
      'destinations'
    );
    if (!quotaCheck.canCreate) {
      return NextResponse.json(
        {
          error: `Destination limit reached. You can create ${quotaCheck.remaining} more destinations. Please upgrade your subscription.`,
        },
        { status: 403 }
      );
    }

    // Check if this is a draft save
    const isDraft = destinationData.isDraft === true;

    // Auto-generate required fields if only name is provided
    const autoGeneratedData = {
      ...destinationData,
      images: destinationData.images || [],
      to_do: destinationData.to_do || `Things to do in ${destinationData.name}`,
      Highlight: destinationData.Highlight || [
        'Explore local attractions',
        'Experience local culture',
      ],
      call_tagline:
        destinationData.call_tagline || `Discover ${destinationData.name}`,
      background:
        destinationData.background ||
        `Experience the beauty of ${destinationData.name}`,
      location: destinationData.location || destinationData.name,
      mini_description:
        destinationData.mini_description ||
        'A wonderful destination to explore',
      description:
        destinationData.description ||
        `This is a beautiful destination with many attractions and activities to enjoy.`,
      published:
        destinationData.published !== undefined
          ? destinationData.published
          : false,
    };

    // For draft saves, provide comprehensive default values for all required fields
    if (isDraft) {
      const draftDefaults = {
        id: destinationData.id || `draft_${Date.now()}`,
        name: destinationData.name || 'Draft Destination',
        images: destinationData.images || [''],
        imageUrl: destinationData.imageUrl || '',
        imageAlt: destinationData.imageAlt || '',
        reviewStars: destinationData.reviewStars || 0,
        to_do: destinationData.to_do || 'Things to do in this destination',
        Highlight: destinationData.Highlight || ['Draft highlight'],
        call_tagline:
          destinationData.call_tagline || 'Discover this amazing destination',
        background:
          destinationData.background ||
          'Experience the beauty of this destination',
        location: destinationData.location || 'Draft location',
        mini_description:
          destinationData.mini_description ||
          'A wonderful destination to explore',
        description:
          destinationData.description ||
          'This is a beautiful destination with many attractions and activities to enjoy.',
        moredes: destinationData.moredes || '',
        position: destinationData.position || 0,
        published: false,
        highlight: destinationData.highlight || false,
      };

      // Merge with provided data, keeping provided values over defaults
      Object.assign(autoGeneratedData, draftDefaults);
    }

    // Only validate required fields if not saving as draft
    if (!isDraft) {
      // Validate required fields
      const requiredFields = ['id', 'name'];

      for (const field of requiredFields) {
        if (!autoGeneratedData[field]) {
          return NextResponse.json(
            { error: `${field} is required` },
            { status: 400 }
          );
        }
      }
    }

    // Connect to database
    await connectDB();

    // Check if destination with same ID already exists for this tenant
    const existingDestination = await Destination.findOne({
      id: destinationData.id.toLowerCase(),
      ...createTenantFilter(userContext.userId, userContext.tenantId),
    });
    if (existingDestination) {
      return NextResponse.json(
        { error: 'Destination with this ID already exists' },
        { status: 409 }
      );
    }

    // Prepare destination data with tenant context and root user reference
    const destinationWithTenant = {
      ...autoGeneratedData,
      userId: userContext.userId,
      rootUserId: userContext.rootUserId, // Add root user reference
      tenantId: userContext.tenantId,
      companyId: userContext.companyId, // Add company ID for multi-tenant isolation
      id: autoGeneratedData.id.toLowerCase(),
    };

    const newDestination = await Destination.create(destinationWithTenant);

    // Increment usage if not a draft (using root user for quota tracking)
    if (!isDraft) {
      await incrementUsage(userContext.rootUserId, 'destinations');
    }

    return NextResponse.json(
      {
        message: isDraft
          ? 'Destination saved as draft successfully'
          : 'Destination created successfully',
        destination: newDestination,
      },
      { status: 201 }
    );
  } catch (error: any) {
    console.error('Create destination error:', error);

    // Handle mongoose validation errors
    if (error.name === 'ValidationError') {
      const validationErrors = Object.values(error.errors).map(
        (err: any) => err.message
      );
      return NextResponse.json(
        { error: `Validation error: ${validationErrors.join(', ')}` },
        { status: 400 }
      );
    }

    // Handle authentication errors
    if (error.message?.includes('Authentication failed')) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      );
    }

    return NextResponse.json(
      { error: 'Failed to create destination' },
      { status: 500 }
    );
  }
}

// GET endpoint to fetch all destinations
export async function GET(request: NextRequest) {
  try {
    await connectDB();

    // Get user context for multi-tenant filtering
    let userContext;
    try {
      userContext = await getUserContext(request);
    } catch (error) {
      // If no authentication, return empty array (for public access)
      return NextResponse.json({ destinations: [] }, { status: 200 });
    }

    // Build query with tenant filtering and root user reference
    const query = {
      rootUserId: userContext.rootUserId, // Filter by root user ID
    };

    console.log('Destinations API - User Context:', {
      userId: userContext.userId,
      rootUserId: userContext.rootUserId,
      companyId: userContext.companyId,
      tenantId: userContext.tenantId,
    });

    console.log('Destinations API - Query:', query);

    // First, let's check if any destinations don't have a position field and set them
    const destinationsWithoutPosition = await Destination.find({
      ...query,
      $or: [{ position: { $exists: false } }, { position: null }],
    });

    if (destinationsWithoutPosition.length > 0) {
      // Set position for destinations that don't have it
      const updatePromises = destinationsWithoutPosition.map((dest, index) => {
        return Destination.findByIdAndUpdate(dest._id, {
          position: dest.createdAt ? new Date(dest.createdAt).getTime() : index,
        });
      });
      await Promise.all(updatePromises);
    }

    const destinations = await Destination.find(query).sort({
      position: 1,
      createdAt: -1,
    });

    console.log('Destinations API - Found destinations:', destinations.length);
    console.log('Destinations API - First destination:', destinations[0]);

    return NextResponse.json({ destinations }, { status: 200 });
  } catch (error) {
    console.error('Get destinations error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
